var WebIsf=require('app/WebIsf');
var WebPml=require('app/WebPml');
var WebDawlati=require('app/WebDawlati');
var AWS = require("aws-sdk");
var doc = require('dynamodb-doc'); // https://www.npmjs.com/package/dynamodb-doc
var config = require('app/config.json');
var Validator = require('app/Validator');
require('app/ArrayEvery');
require('app/ArrayDiff');
require('app/ArrayUnique');

AWS.config.update({region: config.ZBOOTA_SERVER_AWS_REGION});

// JS Class declaration
// For nodejs exports, check bottom of file
var DdbGet = function(event,context,silent,isSync,outputTs) {
// event: structure containing data: car plate number, area, mechanique fields
// context: object with succeed function and fail function
// isSync: force get from web .. used to update data daily
// outputTs: include the lastGetTs and updateTs fields in the output to context.succeed

  this.dynamo = new doc.DynamoDB();
  this.invalid = false;
  this.isSync=!!isSync;
  this.outputTs=outputTs;

  // if event is associative array keyed by area + number, then get values
  if(event.constructor !== Array) {
    var ids = Object.keys(event).map(function(k) { return event[k].a+"/"+event[k].n; });
    if(Object.keys(event).diff(ids).length>0) {
      context.fail("Event should be associative array keyed by area+number");
      this.invalid=true;
      return;
    }
    event = Object.keys(event).map(function(k) { return event[k]; });
  }

  // check that event has correct format
  if(event.constructor !== Array) {
    context.fail("Event should be array");
    this.invalid=true;
    return;
  }
  if(event.length!=event.unique().length) {
    context.fail("Event should not contain duplicates");
    this.invalid=true;
    return;
  }
  if(!event.map(function(x) {
    return x.hasOwnProperty("a")&&x.hasOwnProperty("n")&&!!x.a&&!!x.n;
    }).every()) {
      context.fail("Event elements should all have n and a fields");
      this.invalid=true;
      return;
  }
  if(!event.map(function(x) { return Validator.validArea(x.a); }).every()) {
    context.fail("Some area fields are invalid");
    this.invalid=true;
    return;
  }
  if(!event.map(function(x) { return Validator.validNumber(x.n); }).every()) {
    context.fail("Some number fields are invalid");
    this.invalid=true;
    return;
  }
  if(!event.map(function(x) {
      return (x.hasOwnProperty("hp")&&x.hasOwnProperty("y")&&x.hasOwnProperty("t")) ||
        (!x.hasOwnProperty("hp")&&!x.hasOwnProperty("y")&&!x.hasOwnProperty("t"));
    }).every()) {
      context.fail("Event elements should either have all mech fields or no mech fields");
      this.invalid=true;
      return;
  }
  if(!event.map(function(x) { return !x.hasOwnProperty("l")||!!x.l; }).every()) {
    context.fail("Event elements should either not have l field or have it non-empty");
    this.invalid=true;
    return;
  }

  // context should have succeed and fail functions
  if(!Validator.validContext(context)) throw("Context is invalid");

  //
  this.event=event;
  this.context=context;
  this.data2={};

  silent=!!silent;
  this.silent=silent;
  if(!this.silent) {
    if(!this.isSync) {
      console.log('Received event:', JSON.stringify(event, null, 2));
    } else {
      console.log("sync ddb with web: start ("+event.length+" entries)");
    }
  }
};

DdbGet.prototype.deleteFieldFromData=function(f,id) {
  if(this.data2[id].hasOwnProperty(f)) {
    delete this.data2[id][f];
  }
};

DdbGet.prototype.conclude = function(data,hasMech) {
  this.data2[data.id]=JSON.parse(JSON.stringify(data));
  if(!this.outputTs) {
    this.deleteFieldFromData("lastGetTs", data.id);
    this.deleteFieldFromData("addedTs", data.id);
  }
  this.deleteFieldFromData("emails", data.id);
  this.deleteFieldFromData("l", data.id);
  this.deleteFieldFromData("id", data.id);

  if(!hasMech) {
    this.deleteFieldFromData("dm", data.id);
    this.deleteFieldFromData("hp", data.id);
    this.deleteFieldFromData("t",  data.id);
    this.deleteFieldFromData("y",  data.id);
  }

  if(!this.silent&&this.isSync) console.log("synced "+data.id+" ("+Object.keys(this.data2).length+"/"+this.event.length+")");

  if(Object.keys(this.data2).length==this.event.length) {
    if(!this.silent) {
      if(!this.isSync) {
        console.log('Response to event:', JSON.stringify(this.data2, null, 2));
      } else {
        console.log("sync ddb with web: end");
      }
    }
    this.context.succeed(this.data2);
  } else {
    if(!!this.concludeCb) this.concludeCb();
  }
};

DdbGet.prototype.prepare=function(x,dataIsf,dataPml,existed,dataOriginal,dataMech) {

 // reformat for return
  todayTs=new Date().toISOString().replace(/T/," ").replace(/\..*/,"");
  data=JSON.parse(JSON.stringify(x));
  data.lastGetTs=(this.isSync&&existed&&dataOriginal.Item.hasOwnProperty("lastGetTs")?dataOriginal.Item.lastGetTs:todayTs);
  data.addedTs=(existed&&dataOriginal.Item.hasOwnProperty("addedTs")?dataOriginal.Item.addedTs:todayTs);
  data.isf=dataIsf;
  data.id=x.a+"/"+x.n;
  data.dataTs=todayTs;
  data.pml=dataPml;
  if(dataMech) {
    data.dm=dataMech;
  }

  // store in dynamodb
  //console.log("put",data);
  var self=this;
  this.dynamo.putItem({
     "TableName":"zboota-cars",
     "Item":data
  },function(err,data3) {
     if(err!=null) {
       // http://docs.aws.amazon.com/lambda/latest/dg/programming-model.html
       self.context.fail("Failed to put to dynamodb. "+err);
     } else {
       // return
       self.conclude(data,!!dataMech);
     }
  });
};

DdbGet.prototype.got = function(x) {
  // Integrate getFromWeb parameter, as force parameter in syncCore.php
  // Its role is so the test mech from cache after late addition of mech info will retrieve mech and pass

  var self=this;

  // check existence
  this.dynamo.getItem(
    { "TableName":"zboota-cars",
      "Key":{"id":x.a+"/"+x.n}
    },
    function(err,data) {
      var existed = data!=null && Object.keys(data).length!=0 || data.hasOwnProperty("Item");
      self.got2(err,data,x,existed);
    }
  );
}; // end got function

DdbGet.prototype.getFromWeb = function(data,x,existed) {
  var getFromWeb=!existed;
  var hasMech = x.hasOwnProperty('t') && x.hasOwnProperty('hp') && x.hasOwnProperty('y');

  // modify to true in case of forced request
  if(!getFromWeb) {

    ['t','hp','y'].forEach(function(k2) {
      getFromWeb=getFromWeb||
        (!data.Item.hasOwnProperty(k2) && x.hasOwnProperty(k2)) ||
        ( data.Item.hasOwnProperty(k2) && x.hasOwnProperty(k2) && data['Item'][k2]!=x[k2]);
    });
    ['dm','pml','isf'].forEach(function(k2) {
      if(data['Item'].hasOwnProperty(k2)) {
        if(k2=="dm") {
          getFromWeb=getFromWeb||(data['Item'][k2]=="Not available");
        } else {
          getFromWeb=getFromWeb||(data['Item'][k2]=="Not available" && hasMech );
        }
      }
    });
    var todayD=new Date().toISOString().substr(0,10);
    getFromWeb=getFromWeb||(todayD > data['Item']['dataTs'].substr(0,10));
  }

  return {g:getFromWeb,m:hasMech};
}; // end getFromWeb

DdbGet.prototype.got2 = function(err,data,x,existed) {
  var temp = this.getFromWeb(data,x,existed);
  var getFromWeb=temp.g;
  var hasMech=temp.m;
  var self=this;

  // if no need to get from web
  if(!getFromWeb && !this.isSync) {
    todayTs=new Date().toISOString().replace(/T/," ").replace(/\..*/,"");
    //console.log("found",data,todayTs);
    // update last get timestamp
    // https://github.com/shadiakiki1986/zboota-server-nodejs/issues/3
    this.dynamo.updateItem(
      { "TableName":"zboota-cars",
        "Key":{"id":x.a+"/"+x.n},
        'ExpressionAttributeValues': {':tnow': todayTs},
        'UpdateExpression': 'SET lastGetTs = :tnow'
      },
      function(err,data2) {
        data.Item.lastGetTs = todayTs; // manual set after update
        self.conclude(data.Item,hasMech);
      }
    );
    return;
  }

  // if need to get from web
  //console.log("Did not find",data,x);
  WebIsf.handler(x,function(dataIsf) {
  WebPml.handler(x,function(dataPml) {
    if(hasMech) {
      WebDawlati.handler(x,function(dataMech) {
        self.prepare(x,dataIsf,dataPml,existed,data,dataMech);
      });
    } else {
      self.prepare(x,dataIsf,dataPml,existed,data);
    }
  }); // end WebPml
  }); // end WebIsf

}; // end got2

DdbGet.prototype.get = function() {
  if(this.event.length==0) {
    this.context.succeed({});
    return;
  }

  var self=this;
  if(this.isSync) {
    if(this.event.length==1) {
        this.got(this.event[0]);
    } else {
      // serial loop via callback so as not to overload the servers
      this.getCounter=0;
      this.concludeCb=function() {
        self.getCounter++;
        self.got(self.event[self.getCounter]);
      };
      this.got(this.event[this.getCounter]);
    }
  } else {
    // since dynamodb supports parallel requests
    // make these requests in parallel.
    // Note that a cheaper solution would be
    // to make a batch request and then
    // check which keys don't have results
    this.event.forEach(function(x) {
      self.dynamo.getItem(
        { "TableName":"zboota-cars",
          "Key":{"id":x.a+"/"+x.n}
        },
        function(err,data) {
          var existed = data!=null && Object.keys(data).length!=0 && data.hasOwnProperty("Item");
          self.got2(err,data,x,existed);
        }
      );
    });
  }
};

DdbGet.prototype.DdbGet = DdbGet;

module.exports = function (event,context,silent,isSync,outputTs) {
  return new DdbGet(event,context,silent,isSync,outputTs);
};
